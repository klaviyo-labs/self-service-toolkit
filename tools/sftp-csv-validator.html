<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Validator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-4Q6Gf2aSP4eDXB8Miphtr37CMZZQ5oXLH2yaXMJ2w8e2ZtHTl7GptT4jmndRuHDT" crossorigin="anonymous">
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <!-- libphonenumber-js for phone number validation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/libphonenumber-js/1.10.50/libphonenumber-js.min.js"></script>


</head>
<body>
    <div class="col-lg-8 mx-auto p-4">
        <header class="d-flex align-items-center pb-3 mb-3 border-bottom">
            <h1>SFTP CSV Validator</h1>
        </header>
        <main>
            <p class="fs-6">Some copy will go here explaining what is happening.</p>

            <form>
                <div class="mb-3">
                    <label for="csvFile" class="form-label">Select CSV File:</label>
                    <input type="file" class="form-control" id="csvFile" accept=".csv">
                </div>
                <div class="mb-3">
                    <label class="form-label">Select File Type:</label>
                    <div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="fileType" id="fileTypeEvents" value="events" checked>
                            <label class="form-check-label" for="fileTypeEvents">Events</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="fileType" id="fileTypeProfiles" value="profiles">
                            <label class="form-check-label" for="fileTypeProfiles">Profiles</label>
                        </div>
                    </div>
                </div>
                <div class="mb-3">
                    <button type="button" id="validateButton" class="btn btn-primary">
                        Validate CSV
                    </button>
                </div>
            </form>
        </main>
    
    
    </div>




    <div class="col-lg-8 mx-auto p-4">
        <div id="resultsArea" class="mt-4"></div>
    </div>

    <script>
        // --- DOM Elements ---
        const csvFileInput = document.getElementById('csvFile');
        const validateButton = document.getElementById('validateButton');
        const resultsArea = document.getElementById('resultsArea');

        // --- Header Definitions (ensure they are uppercase for comparison) ---
        const EVENT_IDENTIFIERS_HEADERS = ['PROFILE.EMAIL', 'PROFILE.PHONENUMBER', 'PROFILE.EXTERNALID'];
        const EVENT_REQUIRED_HEADERS = ['METRIC NAME', 'TIME'].map(h => h.toUpperCase());
        const PROFILE_IDENTIFIER_HEADERS = ['EMAIL', 'PHONENUMBER', 'EXTERNALID'];

        /**
         * Appends a message to the results area with appropriate Bootstrap alert styling.
         * @param {string} text - The message text.
         * @param {'success' | 'error' | 'warning' | 'info'} type - The type of message.
         */
        function logMessage(text, type = 'info') {
            const messageDiv = document.createElement('div');
            let alertClass = 'alert-info'; // Default Bootstrap alert type
            switch(type) {
                case 'success': alertClass = 'alert-success'; break;
                case 'error': alertClass = 'alert-danger'; break; // Bootstrap uses 'danger' for errors
                case 'warning': alertClass = 'alert-warning'; break;
                case 'info': alertClass = 'alert-info'; break;
            }
            messageDiv.className = `alert ${alertClass} alert-dismissible fade show mt-2`;
            messageDiv.setAttribute('role', 'alert');
            messageDiv.textContent = text;
            
            resultsArea.appendChild(messageDiv);
        }

        /**
         * Validates a time string against a set of supported ISO-like formats.
         * @param {string} timeString - The time string to validate.
         * @returns {boolean} - True if the time string is valid, false otherwise.
         */
        function validateTime(timeString) {
            if (!timeString) return false;

            const formatsToTest = [
                { regex: /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/, parser: (s) => new Date(s) },
                { regex: /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z$/, parser: (s) => new Date(s) },
                { regex: /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}Z$/, parser: (s) => new Date(s.replace(" ", "T")) },
                { regex: /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}(?::?\d{2})?)$/, parser: (s) => new Date(s) }
            ];

            for (const fmt of formatsToTest) {
                if (fmt.regex.test(timeString)) {
                    const dt = fmt.parser(timeString);
                    if (dt && !isNaN(dt.getTime())) {
                        const year = dt.getUTCFullYear();
                        const month = dt.getUTCMonth() + 1;
                        const day = dt.getUTCDate();
                        
                        const inputYear = parseInt(timeString.substring(0,4), 10);
                        const inputMonth = parseInt(timeString.substring(5,7), 10);
                        const inputDay = parseInt(timeString.substring(8,10), 10);

                        if (year === inputYear && month === inputMonth && day === inputDay) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /**
         * Validates an email string using a regular expression.
         * @param {string} emailString - The email string to validate.
         * @returns {boolean} - True if the email string is valid, false otherwise.
         */
        function validateEmail(emailString) {
            if (!emailString) return false;
            const regex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,7}\b/;
            return regex.test(emailString);
        }

        /**
         * Main validation function.
         * @param {string} csvContent - The content of the CSV file.
         * @param {'events' | 'profiles'} fileType - The type of file being validated.
         */
        function performValidation(csvContent, fileType) {
            resultsArea.innerHTML = '<h2>Results</h2>'; // Clear previous results
            
            validateButton.disabled = true; // Disable button during processing

            setTimeout(() => {
                try {
                    const parseResult = Papa.parse(csvContent, {
                        header: true,
                        skipEmptyLines: true,
                        transformHeader: header => header.toUpperCase(),
                        dynamicTyping: false,
                    });

                    const readerList = parseResult.data;
                    const readerFieldnames = parseResult.meta.fields;

                    if (parseResult.errors.length > 0) {
                        parseResult.errors.forEach(err => logMessage(`CSV Parsing Warning: ${err.message} (Row: ${err.row + 1})`, 'warning'));
                    }

                    if (readerList.length === 0) {
                        logMessage("The CSV file is empty or contains only a header row.", 'info');
                        validateButton.disabled = false;
                        return;
                    }
                    
                    logMessage(`Found ${readerList.length} data rows to validate.`, 'info');
                    let validationPassed = true;

                    let missingRequiredHeaders = [];
                    let missingIdentifiers = false;

                    if (fileType === 'events') {
                        for (const header of EVENT_REQUIRED_HEADERS) {
                            if (!readerFieldnames.includes(header)) {
                                missingRequiredHeaders.push(header);
                            }
                        }
                        if (!EVENT_IDENTIFIERS_HEADERS.some(item => readerFieldnames.includes(item))) {
                            missingIdentifiers = true;
                        }

                        if (missingRequiredHeaders.length > 0 || missingIdentifiers) {
                            if (missingRequiredHeaders.length > 0) {
                                logMessage(`Missing required columns: ${missingRequiredHeaders.join(', ')}`, 'error');
                            }
                            if (missingIdentifiers) {
                                logMessage(`Missing one of the following identifier columns: ${EVENT_IDENTIFIERS_HEADERS.join(', ')}`, 'error');
                            }
                            validationPassed = false;
                        } else {
                            logMessage('Required event headers and identifiers are present.', 'success');
                        }

                        const invalidTimeRows = [];
                        readerList.forEach((row, index) => {
                            const timeValue = row['TIME'];
                            if (timeValue === undefined || timeValue === null || timeValue.trim() === '' || !validateTime(timeValue)) {
                                invalidTimeRows.push(index + 1);
                            }
                        });

                        if (invalidTimeRows.length > 0) {
                            if (invalidTimeRows.length === readerList.length) {
                                logMessage('All rows have an invalid time format in column TIME', 'success');
                            } else {
                                logMessage(`Invalid time in the following rows: ${invalidTimeRows.join(', ')} (column TIME)`, 'error');
                            }
                            validationPassed = false;
                        } else if (readerList.some(row => row['TIME'] && row['TIME'].trim() !== '')) {
                             logMessage('All rows with data have a valid time format in column TIME', 'success');
                        } else {
                            logMessage('TIME column has no data to validate or all entries are empty.', 'info');
                        }

                    } else if (fileType === 'profiles') {
                        if (!PROFILE_IDENTIFIER_HEADERS.some(item => readerFieldnames.includes(item))) {
                            missingIdentifiers = true;
                        }

                        if (missingIdentifiers) {
                            logMessage(`Missing one of the following identifier columns: ${PROFILE_IDENTIFIER_HEADERS.join(', ')}`, 'error');
                            validationPassed = false;
                        } else {
                             logMessage('Required profile identifiers are present.', 'success');
                        }
                    }

                    let emailHeader = null;
                    if (readerFieldnames.includes('EMAIL')) emailHeader = 'EMAIL';
                    else if (readerFieldnames.includes('PROFILE.EMAIL')) emailHeader = 'PROFILE.EMAIL';

                    if (emailHeader) {
                        const invalidEmailRows = [];
                        let processedEmailCount = 0;
                        readerList.forEach((row, index) => {
                            const email = row[emailHeader];
                            if (email && email.trim() !== '') {
                                processedEmailCount++;
                                if (!validateEmail(email)) {
                                    invalidEmailRows.push(index + 1);
                                }
                            }
                        });

                        if (invalidEmailRows.length > 0) {
                            if (invalidEmailRows.length === processedEmailCount && processedEmailCount > 0) {
                                logMessage(`All ${processedEmailCount} non-empty email entries have an invalid format in column ${emailHeader}`, 'error');
                            } else {
                                logMessage(`Invalid email format in the following rows: ${invalidEmailRows.join(', ')} (column ${emailHeader})`, 'error');
                            }
                            validationPassed = false;
                        } else if (processedEmailCount > 0) {
                            logMessage(`All ${processedEmailCount} non-empty email addresses are validly formatted in column ${emailHeader}`, 'success');
                        } else {
                            logMessage(`No email addresses to validate in column ${emailHeader}.`, 'warning');
                        }
                    } else {
                        logMessage('No standard email column (EMAIL or PROFILE.EMAIL) found.', 'info');
                    }


                    let phoneHeader = null;
                    if (readerFieldnames.includes('PHONENUMBER')) phoneHeader = 'PHONENUMBER';
                    else if (readerFieldnames.includes('PROFILE.PHONENUMBER')) phoneHeader = 'PROFILE.PHONENUMBER';

                    if (phoneHeader) {
                        const invalidPhoneRows = [];
                        let processedPhoneCount = 0;
                        readerList.forEach((row, index) => {
                            const phoneNumberStr = row[phoneHeader];
                            if (phoneNumberStr && phoneNumberStr.trim() !== '') {
                                processedPhoneCount++;
                                let parsedNumber = null;
                                try {
                                    parsedNumber = libphonenumber.parsePhoneNumberFromString(phoneNumberStr);
                                } catch (e) {
                                    invalidPhoneRows.push(index + 1);
                                    return; 
                                }

                                if (parsedNumber) {
                                    if (!parsedNumber.isValid()) {
                                        invalidPhoneRows.push(index + 1);
                                    }
                                } else {
                                    invalidPhoneRows.push(index + 1);
                                }
                            }
                        });

                        if (invalidPhoneRows.length > 0) {
                            if (invalidPhoneRows.length === processedPhoneCount && processedPhoneCount > 0) {
                                logMessage(`All ${processedPhoneCount} non-empty phone entries have an invalid format in column ${phoneHeader}`, 'error');
                            } else {
                                logMessage(`Invalid phone format in the following rows: ${invalidPhoneRows.join(', ')} (column ${phoneHeader})`, 'error');
                            }
                            validationPassed = false;
                        } else if (processedPhoneCount > 0) {
                            logMessage(`All ${processedPhoneCount} non-empty phone numbers are validly formatted in column ${phoneHeader}`, 'success');
                        } else {
                            logMessage(`No phone numbers to validate in column ${phoneHeader}.`, 'info');
                        }
                    } else {
                         logMessage('No standard phone column (PHONENUMBER or PROFILE.PHONENUMBER) found.', 'info');
                    }
                    
                    if(validationPassed && resultsArea.children.length > 1) { 
                        logMessage("Overall validation: Some checks passed, but see messages above for details.", 'warning');
                    } else if (validationPassed) {
                         logMessage("Overall validation: All checks passed successfully!", 'success');
                    } else {
                         logMessage("Overall validation: Some checks failed. Please review the messages above.", 'error');
                    }

                } catch (error) {
                    logMessage(`An unexpected error occurred: ${error.message}`, 'error');
                    console.error("Validation Error:", error);
                } finally {
                    validateButton.disabled = false; // Re-enable button
                }
            }, 50); 
        }

        validateButton.addEventListener('click', () => {
            const file = csvFileInput.files[0];
            const fileTypeRadio = document.querySelector('input[name="fileType"]:checked');

            resultsArea.innerHTML = ''; 

            if (!file) {
                logMessage('Please select a CSV file.', 'error');
                return;
            }
            if (!fileTypeRadio) {
                logMessage('Please select a file type.', 'error'); 
                return;
            }

            const fileType = fileTypeRadio.value;
            const reader = new FileReader();

            reader.onload = function(event) {
                const csvContent = event.target.result;
                performValidation(csvContent, fileType);
            };

            reader.onerror = function() {
                logMessage('Error reading file.', 'error');
                validateButton.disabled = false;
            };

            reader.readAsText(file);
        });
    </script>
</body>
</html>
