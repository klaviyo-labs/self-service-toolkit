<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SFTP CSV Validator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-4Q6Gf2aSP4eDXB8Miphtr37CMZZQ5oXLH2yaXMJ2w8e2ZtHTl7GptT4jmndRuHDT" crossorigin="anonymous">
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <!-- libphonenumber-js for phone number validation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/libphonenumber-js/1.10.50/libphonenumber-js.min.js"></script>


</head>
<body>
    <div class="col-lg-8 mx-auto p-4">
        <header class="d-flex align-items-center pb-3 mb-3 border-bottom">
            <h1>SFTP CSV Validator</h1>
        </header>
        <main class="fs-6">
            <p>Select a CSV file to validate prior to an SFTP import. This will validate against the required formatting for <a href="https://developers.klaviyo.com/en/docs/sftp_import_tool#event-csv-formatting" target="_blank">event</a> or <a href="https://developers.klaviyo.com/en/docs/sftp_import_tool#profile-csv-formatting" target="_blank">profile</a> imports.</p>

            <p>This is most useful when building out an SFTP import workflow and confirming the data structure of the first few files before moving to a scheduled job.</p>


            <p>This validates the following:</p>
            <ul>
                <li>Presence of a required identifier (email, phone number or External ID).</li>
                <li>Validity of email or phone formatting.</li>
                <li>Presence of required headers for event imports or profile imports.</li>
                <li>Valid timestamp formatting for event imports.</li>
                <li>Valid consent strings.</li>
                <li>Valid consent timestamp formatting.</li>
            </ul>

            <p>Select a file type (required). Optionally, choose to save line-level validation errors to an output file. Header errors and row numbers for rows with issues will be displayed on this page.</p>

            <hr />

            <form>
                <div class="mb-3">
                    <input type="file" class="form-control" id="csvFile" accept=".csv">
                </div>
                <div class="mb-3">
                    <label class="form-label">Select File Type:</label>
                    <div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="fileType" id="fileTypeEvents" value="events" checked>
                            <label class="form-check-label" for="fileTypeEvents">Events</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="fileType" id="fileTypeProfiles" value="profiles">
                            <label class="form-check-label" for="fileTypeProfiles">Profiles</label>
                        </div>
                    </div>
                </div>
                <div class="mb-3 form-check">
                    <input type="checkbox" class="form-check-input" id="saveErrors" name="saveErrors">
                    <label class="form-check-label" for="saveErrors">Save validation errors</label>
                </div>
                <div class="mb-3">
                    <button type="button" id="validateButton" class="btn btn-primary">
                        Validate CSV
                    </button>
                </div>
            </form>
        </main>
    
    
    </div>




    <div class="col-lg-8 mx-auto p-4">
        <div id="resultsArea" class="mt-4"></div>
    </div>

    <script>
        // --- DOM Elements ---
        const csvFileInput = document.getElementById('csvFile');
        const validateButton = document.getElementById('validateButton');
        const resultsArea = document.getElementById('resultsArea');
        const saveCheckBox = document.getElementById('saveErrors');
        
        let saveOutput;

        // --- Header Definitions (ensure they are uppercase for comparison) ---
        const EVENT_IDENTIFIERS_HEADERS = ['PROFILE.EMAIL', 'PROFILE.PHONENUMBER', 'PROFILE.EXTERNALID'];
        const EVENT_REQUIRED_HEADERS = ['METRIC NAME', 'TIME'];
        const PROFILE_IDENTIFIER_HEADERS = ['EMAIL', 'PHONENUMBER', 'EXTERNALID'];
        const CONSENT_HEADERS = ["EMAIL MARKETING CONSENT", "SMS MARKETING CONSENT", "SMS TRANSACTIONAL CONSENT"];
        const CONSENT_TIMESTAMP_HEADERS = CONSENT_HEADERS.map((header) => `${header} TIMESTAMP`);
        const CONSENT_VALUES = ["SUBSCRIBE", "UNSUBSCRIBED", "NEVER SUBSCRIBED"]

        /**
         * Appends a message to the results area with appropriate Bootstrap alert styling.
         * @param {string} text - The message text.
         * @param {'success' | 'error' | 'warning' | 'info'} type - The type of message.
         */
        function logMessage(text, type = 'info') {
            const messageDiv = document.createElement('div');
            let alertClass = 'alert-info'; // Default Bootstrap alert type
            switch(type) {
                case 'success': alertClass = 'alert-success'; break;
                case 'error': alertClass = 'alert-danger'; break; // Bootstrap uses 'danger' for errors
                case 'warning': alertClass = 'alert-warning'; break;
                case 'info': alertClass = 'alert-info'; break;
            }
            messageDiv.className = `alert ${alertClass} mt-2`;
            messageDiv.setAttribute('role', 'alert');
            messageDiv.textContent = text;
            
            resultsArea.appendChild(messageDiv);
        }

        /**
         * Validates a time string against a set of supported ISO-like formats.
         * @param {string} timeString - The time string to validate.
         * @returns {boolean} - True if the time string is valid, false otherwise.
         */
        function validateTime(timeString) {
            if (!timeString) return false;

            const formatsToTest = [
                { regex: /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/, parser: (s) => new Date(s) },
                { regex: /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z$/, parser: (s) => new Date(s) },
                { regex: /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}Z$/, parser: (s) => new Date(s.replace(" ", "T")) },
                { regex: /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}(?::?\d{2})?)$/, parser: (s) => new Date(s) }
            ];

            for (const fmt of formatsToTest) {
                if (fmt.regex.test(timeString)) {
                    const dt = fmt.parser(timeString);
                    if (dt && !isNaN(dt.getTime())) {
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Validates an email string using a regular expression.
         * @param {string} emailString - The email string to validate.
         * @returns {boolean} - True if the email string is valid, false otherwise.
         */
        function validateEmail(emailString) {
            if (!emailString) return false;
            const regex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,7}\b/;
            return regex.test(emailString);
        }

        /**
         * Main validation function.
         * @param {string} csvContent - The content of the CSV file.
         * @param {'events' | 'profiles'} fileType - The type of file being validated.
         */
        async function performValidation(csvContent, fileType) {
            resultsArea.innerHTML = '<h2>Results</h2>'; // Clear previous results
            
            validateButton.disabled = true; // Disable button during processing

            setTimeout(async() => {
                let writableStream = null;
                try {

                    const parseResult = Papa.parse(csvContent, {
                        header: true,
                        skipEmptyLines: true,
                        transformHeader: header => header.toUpperCase(),
                        dynamicTyping: false,
                    });

                    const readerList = parseResult.data;
                    const readerFieldnames = parseResult.meta.fields;

                    if (parseResult.errors.length > 0) {
                        parseResult.errors.forEach(err => logMessage(`CSV Parsing Warning: ${err.message} (Row: ${err.row + 1})`, 'warning'));
                    }

                    if (readerList.length === 0) {
                        logMessage("The CSV file is empty or contains only a header row.", 'info');
                        validateButton.disabled = false;
                        return;
                    }

                    if(saveOutput){
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: `sftp_validator_errors.csv`,
                            types: [{ description: 'CSV files', accept: { 'text/csv': ['.csv'] } }],
                            startIn: "desktop"
                        });
                        writableStream = await fileHandle.createWritable();
                        await writableStream.write(makeRow(["Row", "Error", "Value"]));
                    }
                    
                    logMessage(`Found ${readerList.length} data rows to validate.`, 'info');
                    let validationPassed = true;

                    let missingRequiredHeaders = [];
                    let missingIdentifiers = false;

                    if (fileType === 'events') {
                        for (const header of EVENT_REQUIRED_HEADERS) {
                            if (!readerFieldnames.includes(header)) {
                                missingRequiredHeaders.push(header);
                            }
                        }
                        if (!EVENT_IDENTIFIERS_HEADERS.some(item => readerFieldnames.includes(item))) {
                            missingIdentifiers = true;
                        }

                        if (missingRequiredHeaders.length > 0 || missingIdentifiers) {
                            if (missingRequiredHeaders.length > 0) {
                                logMessage(`Missing required columns: ${missingRequiredHeaders.join(', ')}`, 'error');
                            }
                            if (missingIdentifiers) {
                                logMessage(`Missing one of the following identifier columns: ${EVENT_IDENTIFIERS_HEADERS.join(', ')}`, 'error');
                            }
                            validationPassed = false;
                        } else {
                            logMessage('Required event headers and identifiers are present.', 'success');
                        }
                        
                        const invalidTimeRows = [];
                        readerList.forEach(async(row, index) => {
                            const timeValue = row['TIME'];
                            if (timeValue === undefined || timeValue === null || timeValue.trim() === '' || !validateTime(timeValue)) {
                                invalidTimeRows.push(index + 2);
                                if(saveOutput){
                                    await writableStream.write(makeRow([index + 2, "Invalid time format", timeValue]));
                                }
                            }
                        });
                        if (invalidTimeRows.length > 0) {
                            if (invalidTimeRows.length === readerList.length) {
                                logMessage('All rows have an invalid time format in column TIME', 'error');
                            } else {
                                logMessage(`Invalid time in the following rows: ${invalidTimeRows.join(', ')} (column TIME)`, 'error');
                            }
                            validationPassed = false;
                        } else if (readerList.some(row => row['TIME'] && row['TIME'].trim() !== '')) {
                             logMessage('All rows with data have a valid time format in column TIME', 'success');
                        } else {
                            logMessage('TIME column has no data to validate or all entries are empty.', 'info');
                        }

                    } else if (fileType === 'profiles') {
                        let hasConsentHeaders = false;
                        let hasConsentHeadersTimestamp = false;

                        if (!PROFILE_IDENTIFIER_HEADERS.some(item => readerFieldnames.includes(item))) {
                            missingIdentifiers = true;
                        }
                        if (missingIdentifiers) {
                            logMessage(`Missing one of the following identifier columns: ${PROFILE_IDENTIFIER_HEADERS.join(', ')}`, 'error');
                            validationPassed = false;
                        } else {
                             logMessage('Required profile identifiers are present.', 'success');
                        }

                        if (CONSENT_HEADERS.some(item => readerFieldnames.includes(item))) {
                            hasConsentHeaders = true;
                        }
                        if (CONSENT_TIMESTAMP_HEADERS.some(item => readerFieldnames.includes(item))) {
                            hasConsentHeadersTimestamp = true;
                        }
                        const invalidConsentValueRows = [];
                        const invalidConsentTimestampRows = [];
                        if (hasConsentHeaders || hasConsentHeadersTimestamp){
                            readerList.forEach(async(row, index) => {
                                
                                let consentValues = CONSENT_HEADERS.map(key => {
                                    return row.hasOwnProperty(key) ? row[key] : "";
                                });
                                consentValues = consentValues.filter(n => n);
                                if (!consentValues.every(async item => CONSENT_VALUES.includes(item))){
                                    invalidConsentValueRows.push(index + 2);
                                    if(saveOutput){
                                        await writableStream.write(makeRow([index + 2, "Invalid consent value"]));
                                    } 
                                }
                                
                                let consentTimestamps = CONSENT_TIMESTAMP_HEADERS.map(key => {
                                    return row.hasOwnProperty(key) ? row[key] : "";
                                });
                                consentTimestamps = consentTimestamps.filter(n => n);
                                consentTimestamps.forEach(async (timeValue) => {
                                    if (!validateTime(timeValue)){
                                        invalidConsentTimestampRows.push(index + 2);
                                        if(saveOutput){
                                            await writableStream.write(makeRow([index + 2, "Invalid consent timestamp format", timeValue]));
                                        } 
                                    }
                                });
                            });
                        }

                        if (invalidConsentValueRows.length > 0) {
                            if (invalidConsentValueRows.length === readerList.length) {
                                logMessage('All rows have an invalid consent value', 'error');
                            } else {
                                logMessage(`Invalid consent value(s) in the following rows: ${invalidConsentValueRows.join(', ')}`, 'error');
                            }
                            validationPassed = false;
                        }
                        if (invalidConsentTimestampRows.length > 0) {
                            if (invalidConsentTimestampRows.length === readerList.length) {
                                logMessage('All rows have an invalid consent timestamp format', 'error');
                            } else {
                                logMessage(`Invalid consent timestamp formats in the following rows: ${invalidConsentValueRows.join(', ')}`, 'error');
                            }
                            validationPassed = false;
                        }

                    }

                    let emailHeader = null;
                    if (readerFieldnames.includes('EMAIL')) emailHeader = 'EMAIL';
                    else if (readerFieldnames.includes('PROFILE.EMAIL')) emailHeader = 'PROFILE.EMAIL';

                    if (emailHeader) {
                        const invalidEmailRows = [];
                        let processedEmailCount = 0;
                        readerList.forEach((row, index) => {
                            const email = row[emailHeader];
                            if (email && email.trim() !== '') {
                                processedEmailCount++;
                                if (!validateEmail(email)) {
                                    invalidEmailRows.push(index + 2);
                                    if(saveOutput){
                                        writableStream.write(makeRow([index + 2, "Invalid email", email]));
                                    }
                                }
                            }
                        });

                        if (invalidEmailRows.length > 0) {
                            if (invalidEmailRows.length === processedEmailCount && processedEmailCount > 0) {
                                logMessage(`All ${processedEmailCount} non-empty email entries have an invalid format in column ${emailHeader}`, 'error');
                            } else {
                                logMessage(`Invalid email format in the following rows: ${invalidEmailRows.join(', ')} (column ${emailHeader})`, 'error');
                            }
                            validationPassed = false;
                        } else if (processedEmailCount > 0) {
                            logMessage(`All ${processedEmailCount} non-empty email addresses are validly formatted in column ${emailHeader}`, 'success');
                        } else {
                            logMessage(`No email addresses to validate in column ${emailHeader}.`, 'warning');
                        }
                    } else {
                        logMessage('No standard email column (EMAIL or PROFILE.EMAIL) found. If other identifiers present, this is not an issue.', 'warning');
                    }


                    let phoneHeader = null;
                    if (readerFieldnames.includes('PHONENUMBER')) phoneHeader = 'PHONENUMBER';
                    else if (readerFieldnames.includes('PROFILE.PHONENUMBER')) phoneHeader = 'PROFILE.PHONENUMBER';

                    if (phoneHeader) {
                        const invalidPhoneRows = [];
                        let processedPhoneCount = 0;
                        readerList.forEach((row, index) => {
                            const phoneNumberStr = row[phoneHeader];
                            if (phoneNumberStr && phoneNumberStr.trim() !== '') {
                                processedPhoneCount++;
                                let parsedNumber = null;
                                try {
                                    parsedNumber = libphonenumber.parsePhoneNumberFromString(phoneNumberStr);
                                } catch (e) {
                                    invalidPhoneRows.push(index + 2);
                                    if(saveOutput){
                                        writableStream.write(makeRow([index + 2, "Invalid phone number", phoneNumberStr]));
                                    }
                                    return; 
                                }

                                if (parsedNumber) {
                                    if (!parsedNumber.isValid()) {
                                        invalidPhoneRows.push(index + 2);
                                        if(saveOutput){
                                            writableStream.write(makeRow([index + 2, "Invalid phone number", phoneNumberStr]));
                                        }
                                    }
                                } else {
                                    invalidPhoneRows.push(index + 2);
                                    if(saveOutput){
                                        writableStream.write(makeRow([index + 2, "Invalid phone number", phoneNumberStr]));
                                    }
                                }
                            }
                        });

                        if (invalidPhoneRows.length > 0) {
                            if (invalidPhoneRows.length === processedPhoneCount && processedPhoneCount > 0) {
                                logMessage(`All ${processedPhoneCount} non-empty phone entries have an invalid format in column ${phoneHeader}`, 'error');
                            } else {
                                logMessage(`Invalid phone format in the following rows: ${invalidPhoneRows.join(', ')} (column ${phoneHeader})`, 'error');
                            }
                            validationPassed = false;
                        } else if (processedPhoneCount > 0) {
                            logMessage(`All ${processedPhoneCount} non-empty phone numbers are validly formatted in column ${phoneHeader}`, 'success');
                        } else {
                            logMessage(`No phone numbers to validate in column ${phoneHeader}.`, 'info');
                        }
                    } else {
                         logMessage('No standard phone column (PHONENUMBER or PROFILE.PHONENUMBER) found. If other identifiers present, this is not an issue.', 'warning');
                    }
                    
                    if(validationPassed && resultsArea.children.length > 1) { 
                        logMessage("Overall validation: Some checks passed, but see messages above for details.", 'warning');
                    } else if (validationPassed) {
                         logMessage("Overall validation: All checks passed successfully!", 'success');
                    } else {
                         logMessage("Overall validation: Some checks failed. Please review the messages above.", 'error');
                    }
                    if (saveOutput){
                        await writableStream.close();
                    }

                } catch (error) {
                    logMessage(`An unexpected error occurred: ${error.message}`, 'error');
                    console.error("Validation Error:", error);
                } finally {
                    validateButton.disabled = false; // Re-enable button
                }
            }, 50); 
        }

        function makeRow(listOfData){
            return (listOfData.join(",")+"\n");
        }

        saveCheckBox.addEventListener('change', async (e) => {
            saveOutput = e.target.checked;
        });

        validateButton.addEventListener('click', () => {
            const file = csvFileInput.files[0];
            const fileTypeRadio = document.querySelector('input[name="fileType"]:checked');

            resultsArea.innerHTML = ''; 

            if (!file) {
                logMessage('Please select a CSV file.', 'error');
                return;
            }
            if (!fileTypeRadio) {
                logMessage('Please select a file type.', 'error'); 
                return;
            }

            const fileType = fileTypeRadio.value;
            const reader = new FileReader();

            reader.onload = function(event) {
                const csvContent = event.target.result;
                performValidation(csvContent, fileType);
            };

            reader.onerror = function() {
                logMessage('Error reading file.', 'error');
                validateButton.disabled = false;
            };

            reader.readAsText(file);
        });
    </script>
</body>
</html>
